####HashMap中的modCount有什么用

####在对key进行hash时，为什么仅让高16位参与运算
> 如果两个hash值低位都一样，高位不参与运算，发生hash碰撞概率更高，高位参与运算，散列会更均匀。


#### hashmap put流程
1.寻址
  1.slot == null：直接占位即可
  2.slow！=null，但正在转向链表
  3.slow村的是链表，尾插法，插入完成后判断是否需要树化。
  4.Slot存的是红黑树（冲突比较严重）

#### 扩容流程
链表：通过用当前key&oldCapcity区分高位链表和低位链表，最终高位链表放到oldCapcity+slotIndex，低位保持原地不动。这么做的目的不仅是为了快，而且还保证了高位链表的hash值与slot关系的正确性。这种扩容方式的前提是，Capcity必须是2的倍数，以数据库分表为例，分16个表，之前hash值4/20/36都落到了表4，16扩容到32后，4和36还是原地不动，而20就会落到（4+16）的位置。
红黑树：红黑树的TreeNode内部还保留着升级前链表的next字段，查询时不用，但resize时，还是通过next来遍历整个tree（如果不存next，遍历tree是需要额外的空间消耗的，即O(N)），也是按照高低位拆分，拆分后的一段如果小于6，则退化成链表；如果拆分后都大于6，则将该链表重建红黑树。

#### HashMap扩容时导致的CPU100%具体是怎么发生的
并发扩容时导致链表形成闭环。
扩容前，在2个线程看来链表时顺序存储，假如线程1在遍历时换出了，此时线程2拿到了时间片进行先rehash后，因为采用了头插法，导致rehash后的链表从顺序变成了逆序的。而此时在切回线程1时，当前游标和next指针虽然未变，但next的next已经发生了变化，而且是next.next=当前游标，这下就形成了闭环

