### Java中如何创建一个对象的（以关键字new为例）
 1) 判断new的类型是否已经在方法区中加载（涉及JVM类加载过程，在第7章再整理）TODO
 2) 为对象预分配内存空间，为了克服不同线程分配内存时的并发问题，一般是采用2种策略来保证内存分配线程安全：
   a) 优先采用TLAB分配，即在线程私有栈空间上直接分配，直接避免了线程安全问题
   b) 如果TLAB分配不下，则同步锁定，进行内存分配。
 3) 为对象的成员变量初始化零值
 4) 为对象初始化MarkWord
 5) 调用构造对象的构造方法

### Java对象在内存中是如何布局的
 1) MarkWord
   都存了哪些数据
 2) 实例数据
 3) 对齐填充：因为JVM定义了Java对象占用空间大小必须是8的倍数，因此仅靠MarkWord和实例数据不等于8的倍数时，需要通过对齐填充来凑数。
 【8的倍数应该是对CPU加载友好一些吧？】

### intern分配规则
 1) JDK6：因为还存在永久代的原因，intern方法会把「首次」遇到的字符串实例copy到永久代的常量池中存储
 2) JDK7：常量已经移到了Heap中，因此直接在Heap中分配内存
[问题]这段代码在JDK6和7运行结果差别，以及原因是什么？
	`-------
	public static void main(String[] args) {
		String s1 = new StringBuilder("计算机").append("软件").toString();
		System.out.println(s1.intern() == s1);
		
		String s2 = new StringBuilder("ja").append("va").toString();
		System.out.println(s2.intern() == s2);
	}
	-----------
  在JDK6中会输出2个false：因为6中intern返回的对象在永久代中分配的，而s1对象时在heap中，因此两个对象地址肯定不等。
  在JDK7中会输出1个true，一个false：因为7中intern都是在heap中分配，所以两者相等。而第二个false，是因为「java」是一个比较特殊的字符串，详情搜知乎吧，关于intern还有其他规则，不打算深入研究了，本身intern也就在面试中用到。


######【FollowUp】
[p45] 逃逸分析和标量优化是什么意思（参考11章）
[p45] TLAB如何提高线程分配对象效率的？
[p46] 为什么删除了永久代，取而代之用了元空间?
[p47] 直接内存如何回收
[p48] cms收集器是怎么处理内存碎片的
[p52] java创建对象，在给字段分配内存空间时，为什么要将相同宽度的值连续在一起？而不是按照字段定义顺序
java对象为什么要对齐，为什么一定要用8的倍数，对CPU友好在哪？
[p52] 句柄和直接指针有什么区别？
