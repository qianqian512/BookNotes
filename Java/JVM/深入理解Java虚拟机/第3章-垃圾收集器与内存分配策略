### 3.2 判断对象可回收的几种方式以及适用场景，尽量举例论证说明
  引用计数实现简单，使用效率高，只是简单的判断一下计数器是否等于0就可判定对象是否要回收，但缺点是对于循环引用无可奈何，而引用链的方式则正好想法。
  [补充] 分析一下常用中间件都是用什么方式判断「对象已死？」
   Java：因为Java支持循环引用的写法，因此只能使用引用链方式判定；
   Redis：Redis对象比较简单，不存在对象套对象的写法，因此采用了引用计数方式，在一个key过期被从redis实例中踢除时，还需判断对应的value是否还有其他key共享。
   Memcache：memcache不会释放内存，而是重新利用。假如当key过期时memcache并不会直接释放掉段内存，而是当有需要同等大小的请求时，直接将过期的值覆盖，然后复用这段空间。
   MongoDB/MySQL：网上资料比较少，个人推断虽然这两者也是作为存储组件存在，但数据更多的是写在磁盘上，因此好像对于value不敏感。

### 3.3 垃圾收集算法有哪些，分别用于哪些场景，尽量举例论证说明

### 3.4 HotSpot算法细节，这节需要细读一下，看目录好多名词没见过

### 3.5 这节除了了G1以外几乎都知道，但需要注重整理一下，个别GC已经弄混了

#### CMS收集器
 1.CMS收集器为什么要进行3次标记操作
 2.CMS收集器第一次和第三次标记操作为什么要设计成STW，如果和用户线程并行有什么问题吗？
   a) 第一次初始标记一定要设计成STW，主要是为了避免用户线程和GC线程在读写ThreadStack时并发问题。假设第一次标记不进行STW，由于用户线程处于执行中，
      导致每个线程的ThreadStack不断进行入栈出栈，其实就是GC-ROOT在不断的发生变化，而此时GC线程需要读取GC-ROOT，除非ThreadStack被设计成线程安
      全的Stack，否则并发读写将出现不可预见的问题。进一步思考，将ThreadStack设计成线程安全的对象，还不如直接在第一次标记时STW，让GC单线程处理。
   b) 第三次标记STW原因.....

#### G1
 1.线上G1配置参数？一般分了多少个Region、每次停顿多长时间？
 2.我理解G1不是没有新生代了吗，怎么还有younggc或fullgc
 3.我们公司monitor系统对younggc的触发和监控时长是通过什么方式检测到的
 4.G1的内存布局是每个region大小都固定，且在1-32M之间，如果分配一个超过32M的内存对象，该如何分配？
 5.G1将Heap分成了多个Region后，在gc时清理跨region的引用对象时怎么办？(参考3.3.1和3.3.4)
 6.在并发标记时，如果保证gc线程和用户线程互不干扰(参考3.4.6)
 7.怎样建立可预测停顿模型
 8.G1在gc时为什么要进行3次标记
 9.G1在发生fullgc时，是怎么清理内存的？和普通mirorgc...清理时是不是不区分minorgc

### 3.6 低延迟垃圾回收器，没见过，需要学习一下

### 3.7 如何选择合适的垃圾收集器
  1) Epsilon是什么收集器 

### 3.8 
  1) 晋升老年代的条件是什么？
  2) 
  
####FollowUp
 1.强软弱虚4个引用怎么使用？源码中是如何使用这些引用的？
 2.cms失败后会触发fullgc，那么这时的fullgc用什么gc收集器清理老年代，不还是cms吗？
 3.为什么fullgc会慢，fullgc都做了哪些事情，这些事情分布时间占比大概是多少？