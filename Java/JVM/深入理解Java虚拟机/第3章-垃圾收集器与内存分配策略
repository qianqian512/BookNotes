### 3.2 判断对象可回收的几种方式以及适用场景，尽量举例论证说明
  引用计数实现简单，使用效率高，只是简单的判断一下计数器是否等于0就可判定对象是否要回收，但缺点是对于循环引用无可奈何，而引用链的方式则正好想法。
  [补充] 分析一下常用中间件都是用什么方式判断「对象已死？」
   Java：因为Java支持循环引用的写法，因此只能使用引用链方式判定；
   Redis：Redis对象比较简单，不存在对象套对象的写法，因此采用了引用计数方式，在一个key过期被从redis实例中踢除时，还需判断对应的value是否还有其他key共享。
   Memcache：memcache不会释放内存，而是重新利用。假如当key过期时memcache并不会直接释放掉段内存，而是当有需要同等大小的请求时，直接将过期的值覆盖，然后复用这段空间。
   MongoDB/MySQL：网上资料比较少，个人推断虽然这两者也是作为存储组件存在，但数据更多的是写在磁盘上，因此好像对于value不敏感。

### 3.3 垃圾收集算法有哪些，分别用于哪些场景，尽量举例论证说明

### 3.4 HotSpot算法细节
 1.线程运行时设置OopMap
 2.当需要GC时，所有执行中的线程必须跑到SafePoint然后中断
 3.不在执行中的线程(处于Block或Sleep状态)处于SafeRegion
 4.遍历OopMap，根据可达性分析，区分标记出存活对象与垃圾对象
 5.然后根据区域和具体GC实现进行清除、复制、整理算法
 6.如果GC过程中，有Sleep的线程醒来，由于在SafeRegion也需要等待GC线程执行完。
#### 3.4.1 根节点枚举
 1.在GC根节点枚举时为什么一定要StopWorld？
   如书中所言，是为了保证GC时准确性，猜测如果这个环节GC线程和用户线程并行，可能会导致被GC线程标记为回收的对象，因为用户线程原因而再次引用导致被误GC。
 2.为什么需要OopMap，GC时直接线程堆栈中栈帧内的局部变量作为GC-Root去遍历有什么问题吗？会很慢吗，为什么要引用OopMap。
   因为HotSpot虚拟机采用了「准确式垃圾收集」方式，所以JVM必须单独有一个地方存储了哪些地方存储了对象引用。如果采用「保守式垃圾收集」直接从GC-Roots遍历，仅在栈中识别指针和非指针比较耗费成本。
   JVM如何判断数据是引用还是基本数据参考这篇文章：https://blog.csdn.net/Leeycw96/article/details/90704760
 3.OopMap中存的是什么数据，内部存储结构是什么样的？
   OopMap用于保存正在执行线程中引用与对象的关系。换句话说就是记录了当前线程栈中的引用类型的局部变量，以及对应引用了堆中的对象的关系。通过OopMap能够快速检索出引用类型变量。
 4.GC-Root区分新生代和老年代吗，如果只出发MirorGC，从GC-ROOT搜索怎么避开搜索老年代？

#### 3.4.2 安全点
 什么是安全点: 为了配合OopMap进行GC，只在特定的位置记录了GCRoot枚举，这些位置就是安全点，一般选取位置就是循环跳转，方法调用等地方。
 为什么要使用安全点: 因为在程序运行过程中，需要记录引用和对象的关系
 安全点是如何配合OopMap工作的:

#### 3.4.3 安全区域
 1.

### 3.5 这节除了了G1以外几乎都知道，但需要注重整理一下，个别GC已经弄混了

#### 3.5.6 CMS收集器
 CMS收集器工作目的：
   垃圾收集时，更为关注系统的响应速度，减少GC停顿时间为主。
 CMS收集器工作原理：
   1.初始标记，标记出GC-Root直接关联的对象，该步骤是Stop-World操作
   2.并发标记，根据初始标记的对象遍历标记所有引用的对象，该步骤GC线程与用户线程并行
   3.重新标记，修正并发标记期间，用户线程增量变更产生的影响
   4.并发清除

【问题】
  1.CMS收集器为什么要进行3次标记操作
  2.CMS收集器第一次和第三次标记操作为什么要设计成STW，如果和用户线程并行有什么问题吗？
   	a) 第一次初始标记一定要设计成STW，主要是为了避免用户线程和GC线程在读写ThreadStack时并发问题。假设第一次标记不进行STW，由于用户线程处于执行中，
       导致每个线程的ThreadStack不断进行入栈出栈，其实就是GC-ROOT在不断的发生变化，而此时GC线程需要读取GC-ROOT，除非ThreadStack被设计成线程安
       全的Stack，否则并发读写将出现不可预见的问题。进一步思考，将ThreadStack设计成线程安全的对象，还不如直接在第一次标记时STW，让GC单线程处理。
   	b) 第三次标记STW原因：因为在第二次并发标记时，由于用户线程的改变引用可能导致存在漏掉垃圾或引用消失问题，因此基于第三次标记要重新STW，来保证GC正确性。
  3.CMS回收过程中，最耗时的是那个环节的操作？
    a) 并发标记: 如果说第一次标记GCRoot是线性遍历，那么并发标记就是基于GCRoot产生的图状遍历。
    b) 并发清除: 
  4.在并发标记阶段，CMS收集器是如何避免GC线程回收有效引用的？
    使用增量更新的方式，当黑色引用指向白色引用时，将其记录为增量数据，待并发扫描结束后，再将黑色节点重新扫描。
     a) 正常情况下黑色节点不会直接指向白色节点，往往是灰色或黑色。
     b) 黑色节点代表扫描过的节点，再次进行扫描往往都是因为增量数据导致的。
  5.CMS的缺点：
     a) 对CPU资源敏感，当处理器核心数量不足4时，GC线程对用户线程影响比较明显。
     b) 因为CMS采用标记清除算法，所以GC完后会有浮动垃圾；
     c) 且在CMS运行期间，如果预留内存无法满足程序新分配对象的需求，则会出现「并发失败」，则启用SerialOld重新一次GC。
       【思考】「并发失败」后的GC会Stop World，为什么不采用ParOld而是采用SerialOld，猜测应该是GC架构遗留问题导致。之前看过之所以几个GC引擎无法兼容，是因为框架导致。
  
#### G1
 1.线上G1配置参数？一般分了多少个Region、每次停顿多长时间？
 2.我理解G1不是没有新生代了吗，怎么还有younggc或fullgc
 3.我们公司monitor系统对younggc的触发和监控时长是通过什么方式检测到的
 4.G1的内存布局是每个region大小都固定，且在1-32M之间，如果分配一个超过32M的内存对象，该如何分配？
 5.G1将Heap分成了多个Region后，在gc时清理跨region的引用对象时怎么办？(参考3.3.1和3.3.4)
 6.在并发标记时，如果保证gc线程和用户线程互不干扰(参考3.4.6)
 7.怎样建立可预测停顿模型
 8.G1在gc时为什么要进行3次标记
 9.G1在发生fullgc时，是怎么清理内存的？和普通mirorgc...清理时是不是不区分minorgc

### 3.6 低延迟垃圾回收器，没见过，需要学习一下

### 3.7 如何选择合适的垃圾收集器
  1) Epsilon是什么收集器 

### 3.8 
  1) 晋升老年代的条件是什么？
  2) 
  
####FollowUp
 1.强软弱虚4个引用怎么使用？源码中是如何使用这些引用的？
 2.cms失败后会触发fullgc，那么这时的fullgc用什么gc收集器清理老年代，不还是cms吗？
 3.为什么fullgc会慢，fullgc都做了哪些事情，这些事情分布时间占比大概是多少？
 4.怎么区分新生代和老年代的GCRoot?