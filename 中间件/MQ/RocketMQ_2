#### 如何保证消息的顺序
  RocketMQ无法从Topic层面完全保证消息的顺序性，但能从队列层面保证消息顺序性。但有一些折中方案，例如牺牲可用性使用单点queue；或者发消息时根据消息标识选择分片，例如mq中虽然有4个队列，单订单id等于465637615的消息总是路由到同一个队列中。
  但即便如此，方案2中也不是完善的方案，例如异步发送消息1，2，3时，2失败了又重试，此时队列的顺序变成了132。又或者发送时broker宕机，此时消息就又会被发到了不同的分区，导致消息顺序短暂不一致。
  而从consumer角度，一般一个consumer实例下，会有多个worker线程在消费，多个线程之间在消费时无法保证消费顺序。但rocket的ConsumeMessageOrderlyService可以保证局部顺序性：consumer内部的队列上锁，保证队列串行，多个队列实现分片机制保证并行。

### 如何保证消息不会丢
  (a) 发消息时，如果采用同步发送，则请捕获异常。如果采用异步发送，则需要监听回调事件是否成功 
  (b) 存储阶段，单节点broker可以采用同步刷盘机制保证，多个节点broker可以通过配置，将节点写成功超过2个以上才返回成功
  (c) 消费阶段，保证业务逻辑完成再回应ack

### 消息积压了怎么办
  (a) 扩容consumer，扩容时记得查看队列数量，保证大于consumer数量
  (b) 排查具体问题原因，确认是consumer消费突然慢了，还是producer突然生产多了，一般通过监控可以看出来。

#### rocketmq部署架构，如何保证高可用

#### rocketmq为什么不像kafka采用zk作为注册中心，而是采用nameserver
根据CAP理论，同时最多只能满足两个点，而zookeeper满足的是CP，也就是说zookeeper并不能保证服务的可用性，zookeeper在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。
