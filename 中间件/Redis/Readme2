##基础篇

### Redis的数据类型和底层存储结构对应关系
  #### 简单动态字符串-SDS
	What：Redis内置字符串数据结构，是Redis String类型对应的存储结构。
	Why：C语音中的字符串和Java中的类似，是一种不支持修改的数据结构，而Redis需要的字符串恰恰是需要允许修改的。
	Where：SDS最常见的使用场景就是作为redis的key使用；AOF缓冲区；客户端的输入缓冲区。
	* 优点：获取字符串长度是O(1)复杂度；减少频繁修改而导致多次扩容（SDS扩容的分水岭在1M临界点：1M内每次2倍扩容；超过1M每次以1M速度扩容）；惰性释放（SDS在修改后的空余位置不会立即回收，这不确定算是缺点还是优点）
	sdshdr {
	  free : 剩余可用字节长度,
	  len : 字符数组长度,
	  buf : 字符数组
	}
   【思考】redis为什么不沿用c的原生数组
   	  1) 考虑redis中的字符串频繁修改的可能性更高一些，因此记录了字符串的len和free可以快速的判断是在原地修改还是需要分配新的空间。
   	  2) redis的sds使用了len和free，存储使用字节数组，所以面向的数据格式更加广泛，可以存储包含任意二进制数据格式。
   【思考】redis的sds既然用了len和free表示长度，为什么还要用\0作为末尾分隔符
   	  猜测应该主要是为了兼容c的api，所以遵循了原有c的格式。
  #### 链表
    What: Redis中的链表是一个双向无环链表。
    Where: 链表作为List类型的底层存储结构之一以外，其他功能诸如发布订阅、慢查询、监视器等功能也用到链表，Redis服务端本身还用链表保存了多个客户端的状态信息。
    list {
       head *listNode : 头节点
       tail *listNode : 尾节点
       len : 链表长度
    }
    listNode {
       prev : 前驱节点
       next : 后继节点
       value : 链表值
    }
   【思考】redis的list为什么要选用链表存储，而并不用线性表。
         相比链表，线性表虽然随机读很快，但写性能肯定不如链表高效，尤其在线性表扩容时更是性能上的一个隐患；对于Redis操作，基本不会根据下标读取元素，反倒是双向链表对List类型的API支持更加友好，例如lpush，lrem等。
  #### 字典结构-Hash
	What：最基本的k-v结构，
	Where：Redis中的hash结构应用非常广泛，例如redis数据库就是采用hash结构实现的，最常见的set就是将一组k-v塞到了hash中；还有Hash数据类型在数据量达到一定阈值时也会从压缩列表演变成hash表。
	dictht {
		table : 哈希表数组(dictEntry)
		size : 哈希表大小 
		sizemask : 掩码，用于计算hash值使用，总是恒等于size-1
		used : hash表已有节点数量
	}
	dictEntry {
		key : 键
		union {
			val : 值对象指针
			u64 : 有符号整型
			s64 : 无符号整型
		} // 值（根据value类型，选用里面3个字段中的一个使用）
		next : 发生hash冲突时，指向的下一个hash节点，最终冲突的节点形成链表。
	}
	dict {
		type : 类型函数，dict应用比较广泛，而dict本身是一个抽象模型，因此对k-v的操作并没有在函数定义时强行限制，而是靠调用者传入从而更加灵活。
		privatedata : 配合type使用，负责存type所需的参数
		ht[2] : 这里是一个包含2个元素的hash数组，ht[0]是正在使用的hash，ht[1]一般是在rehash进行迁移时使用。
		trehashidx : rehash标识，等于-1时代表没有进行rehash操作
	}
	* Redis中的Hash结构什么时候进行扩容和收缩
	  满足一下任意一个时触发扩容条件：
	    1) 服务器没有BG-SAVE或BG-REWRITE-OF命令，Hash负载因子等于1时；
	    2) 服务器正在执行BG-SAVE或BG-REWRITE-OF命令，Hash负载因子等于5时；
	  其中负载因子计算公式：
	    load_factor = ht[0].used / ht[0].size;
	  另一方面，当负载因子小于0.1时，hash开始进行收缩操作。
	* 针对上面为什么BG-SAVE时，redis需要把load_factor阈值提高
	  为了避免redis主进程fork出的bg进程在使用copy-on-write时频繁的触page-fault。
	 【补充】copy-on-write计算原理：
	  1.在不适用copy-on-write技术时，父进程在fork子进程时，子进程会copy一份父进程的内存作为自己的存储空间，从此以后父子存储相互独立。
	  2.基于1的模式，现实中fork出的子进程往往和父进程做的工作不同，因此copy出父进程的内存快照没有任何用处，这里就需要引入exec命令集。
	  3.子进程要做自己想做的事情，就需要先装在必要的内存数据，因此exec函数的目的是：装在一个新的可执行程序覆盖原有内存，这样子进程调用完exec就可以做自己的要做的工作了。
	  4.经历完前面的1-2-3后发现，fork时子进程copy父进程的快照后但没有使用，属于浪费资源的操作，因此就引入了copy-on-write机制。
	  5.copy-on-write达到的目的是，fork出的子进程不会copy父进程快照，而是采用与父进程共享，但这段共享区域一旦发生写操作，子进程会立刻copy出一份副本来保持两方独立，互不干涉，这就是page-fault
	  6.因此在回过来看rehash操作与copy-on-write的影响，由于rehash肯定是发生在父进程上，虽然redis采用渐进式rehash，但还是不可避免的发生了更多的写操作，与fork出的bg子线程发生冲突，产生了过多
	    的page-fault，而写操作又不可避免，那么只能调整hash负载因子的阈值，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存（阈值调大后就不扩容了，也就不会因为rehash而进行渐进式迁移
	    了，不迁移了写操作就减少了）。
	* 渐进式Hash
	   为了避免一次性集中迁移导致master线程阻塞，Redis采用渐进式迁移。渐进式迁移发生的时机是，每次对key所在的下标进行读取或写入。最终将所有迁移工作，平摊到每个时间点上。
	  【补充】在rehash过程中(rehashIdx不等于-1时)，由于key可能已经迁移或未迁移，因此在操作时也会在ht[0]和h1[1]上操作。
	
  #### 跳表（skiplist）
    What：跳表是一种有序的存储结构，是一种支持二分查找的链表结构，其内部通过维护一个多层的链表，且上层链表中的元素是下一层链表元素的子集，越往上则越稀疏。在搜索时，跳表则现在上层的稀疏链表中搜索，当节点值
         小于等于目标值时，则向下查找；如果节点值大于目标值，则继续在同层遍历向后查找。平均查找效率是O(logN)，最坏情况是O(n)，删除修改效率同查找，取决于find效率，而找到目标节点后，链表修改或删除复杂度是O(1)。
    Where：跳表在Redis中使用并不是非常广泛，仅在实现zset类型使用。
    * 思考：Redis为什么不选用B+Tree来代替跳表？
		抛开两者的实现复杂度不提；Redis和MySQL数据存储介质不同，前者数据存在内存中，后者数据存储在硬盘里，而B+Tree主要是通过降低层高来减少访问磁盘次数，而Redis不涉及，所以选择了跳表。
		
  #### 整数集合（intset）
    What：整数集合顾名思义，就是一个集合中的所有元素都是整数。底层用了一个int数组来升序保存着整型数值，其中int的长度取决于另一个字段encoding（int16/int32/int64），为了节省内存，在存储时尽可能用更小的int类型
         一旦新增元素超过存储边界，则整个int数组会进行一次大的升级，例如从int16->int32或者int16->int64。intset支持升级，但不支持降级（注意一点，intset的整型长度都是有符号类型）。
    Where：作为set类型的底层存储，当元素不多且集合内都是整型时使用。
    intset {
    	encoding : 编码方式 int16/int32/int64
    	length : contents中元素的数量
    	contents : 数组类型，用来存储整型数据
    }
   【Q1】intset是如何保证不重复的？
    	intset内部维护了一个从小到大的有序的数组，因此插入时会根据顺序的特性判断是否重复，但这样引入了一个新的问题就是插入和删除的效率问题。例如当插入一个较小元素时，会导致数组大部分元素都要后移，但好在intset仅在数据规模小
    	时作为底层存储结构，因此猜测这点损耗Redis应该是可以接受。
    
  #### 压缩列表（ziplist）
    What：压缩列表是为了界具有Redis内存而开发的一种独有的数据结构，可以理解为是一个动态类型节点的线性表，其中它的节点值类型支持大体可以分为2大类：
    		1) 直接存储字节数组，存储的长度类型分为：
    			【63字节】2的6次方 - 1			占用1字节，高2位存储类型(00)，低6位存储长度，最大长度是6个1
    			【16383字节】2的14次方 - 1		占用2字节，第1个字节的高2位存储类型(01)，第1个字节的低6位+后1个字节存储长度，最大长度是14个1
    			【42亿】2的32次方 - 1			占用5字节，第1个字节的高2位存储类型(10)，后4个字节存储长度，最大长度是4G
    		2) 存储数字：
    			【4位】有符号整数  	（0 ~ 12）
    			【1字节】有符号整数		（0 ~ 255）
    			【3字节】有符号整数		（0 ~ 65535*8）
    			【int16】			（-3W ~ 3W）
    			【int32】			（-21亿 ~ 21亿）
    			【int64】			（略）
  	Where：是“列表键”和“hash键”的底层实现之一，当满足下面3个条件一个时，redis会用ziplist作为存储结构
  	        1) 列表键中元素数量较少
  	        2) 每个元素均是小整数值
  	        3) 长度比较短的字符串
	【Q1】关于ziplist中node节点的encoding字段：
		记录了节点的类型，使用一个字节保存了9种类型，高2位非11开头的3中数值代表content存的是数组；而高2位11开头的代表存的整数数值。这里还有一个极致的空间压缩，当encoding的高4位是1111，
		但低4位不是0000和1110时，redis将0~12之间的value存储在低4位中，从而节省了content占用的空间，也就是说我们用的value是0~12之间的数字时，encoding既存了类型也存了value。
		
  	【Q2】为什么不用链表代替列表呢？
  	【Q3】ziplist的连锁更新的用途？
  	【Q4】ziplist这种数据线性存储结构，插入数据时，数据怎么移动的？例如lpush这种命令？感觉时间复杂度会不会很高？
  	
  #### 对象（Object）
    What：
  	Where：存储大于 44 个字节的字符串
     

#### 4.redis数据类型和底层结构对应关系(什么时候会进行底层数据结构转换)
 String - 字符串 - set/get/mset/mget - sds/Object
 List - 线性数组 - lpush/lpop - 双向链表，压缩列表
 Hash - k-v存储 - hset/hget - 压缩列表，哈希表
 SortedSet - 有序集合 = zadd/zrange/zincrby - 压缩列表，跳表
 Set - 不能重复集合 - sadd/spop - 哈希表，整数集合
  
#### Redis存储结构实现

#### Redis集群方案

#### Redis使用经典场景的案例



##问题篇

#### 对比Redis作为消息队列和其他消息队列的差异
 1.实时性：满足
 2.功能性：redis5.0的Stream数据结构满足了消息分组的要求
 3.顺序性：在5.0之前，可以用list数据结构保证顺序性;5.0之后Stream可以保证顺序性
 4.消息重复：由消费者自己判断是否重复消费
 5.消息可靠性：
 
#### 哪些操作可能会影响到Redis阻塞
 1.写入或删除一个big key在分配或释放内存时会消耗更多的时间(big value不会吗)
 2.复杂度较高的命令，例如2个大list取交集
 3.淘汰策略：淘汰策略也是由master线程完成的，当内存达到上限后，每次写操作都要进行淘汰删除一些key，也会降低redis吞吐量
 4.AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 
 5.主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
 6.并发量非常大时，redis在反序列化客户端请求时，无法利用多CPU特性，redis6.0推出了在对客户端数据编解码时，采用多线程方式，而命令操作时在内存中依旧是单线程。
 
#### Redis的优化点
 1.ziplist中存储0~12数值，这种value应该非常常见，因此redis采用了比较极致的压缩手段。假如我们的场景是需要使用list类型存储大量的状态标识，那么这其中的value最好就选用0~12来存储。
 
#### 从Redis中学到了什么
 1.没有完美的数据结构，redis的经典数据结构也都是基于场景出发
 	a) ziplist的连锁更新复杂度会达到O(n²)。但好在场景并不多见；如果list长度不大，也没有问题。
 	b) intset在插入或删除靠前面的元素时，会导致后面元素都要跟着移动。但好在intset定位存储数据规模小
 
 ## Redis命令篇
 #### 查看一个key底层使用的存储结构
  object encoding [key]