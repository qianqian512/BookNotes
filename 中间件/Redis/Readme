#### 1.面对小段或大段数据，采用什么样的内存分配器

#### 2.redis 的rehash过程
 1) 给哈希表2分配更大的空间，例如是当前哈希表 1 大小的两倍；
 2) 把哈希表1中的数据重新映射并拷贝到哈希表 2 中；
 3) 释放哈希表1的空间。
 4) 采用渐进式迁移，避免主线程阻塞。

#### 3.redis底层数据结构对比
 sds
 双向链表
 压缩链表
 哈希表
 调表
 整数数组

#### 4.redis数据类型和底层结构对应关系(什么时候会进行底层数据结构转换)
 String - sds
 List - 线性数组 - 双向链表，压缩链表
 Hash - k-v存储 - 压缩链表，哈希表
 SortedSet - 有序集合 - 压缩列表，跳表
 Set - 不能重复集合 - 哈希表，整数数组
 
#### 5.整数数组和压缩列表在查找上优势并不大，为什么还需要呢？
 1) 内存利用率更高
 2) 对CPU高速缓存更加友好，小数据量时CPU在随即读取时，会一次性将一段连续内存读入到高速缓存，一般一个缓存行是64字节，对整数数组而言，如果只有16个以内，基本也可以认为是O(1)读取
 
#### 6.redis单线程为什么快
 1) 对redis而言都是基于内存操作，因此单线程不仅不存在阻塞的情况，而且海避免了多线程之间竞争的开销。
 2) 另一方面redis单线程采用多路复用的NIO线程模型

#### 7.redis的线程模型
 1) 主线程：NIO（待整理）
 2) 后台线程:AOF线程，expired线程
 
#### 8.Redis 6.0 中提出了多线程模型是什么样的？
 待确认？？？ 6.0之前版本，主线程既负责编解码，又负责执行操作命令；6.0后的版本，应该是将线程分为了编解码线程集合和工作线程，其中编解码线程集合负责对redis传入的数据命令行进行序列化反序列化操作；而工作线程仍然是单线程，只负责执行redis指令。

#### 9.Redis单线程处理IO请求性能瓶颈
 存在慢查询操作会阻塞master线程，导致整个server吞吐量下降
  1) 写入或删除一个big key在分配或释放内存时会消耗更多的时间(big value不会吗)
  2) 使用复杂度比较高的命令，
  3?) 大量key集中过期：由于redis的过期删除机制，也是由master线程完成的(另一汇回答：大量的 key 过期并不会导致 redis 主线程阻塞。redis 是使用 lazy 以及后台周期采样删除的机制淘汰过期 key)
  4) 淘汰策略：淘汰策略也是由master线程完成的，当内存达到上限后，每次写操作都要进行淘汰删除一些key，也会降低redis吞吐量
  5?) AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 
  6?) 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
 并发量非常大时，redis在反序列化客户端请求时，无法利用多CPU特性，redis6.0推出了在对客户端数据编解码时，采用多线程方式，而命令操作时在内存中依旧是单线程。

#### 10.Redis在将数据落盘时为什么采用写后日志(AOF)，相比mysql的写前日志(WAL)，应用场景有什么不同？
 写后日志的好处：先执行成功再写日志，不会阻塞当前线程写操作
 写前日志的优势：mysql使用 redo Log + binLog 二阶段提交(prepare + commited),保证已提交的数据不会丢失，保证事务和一致性，而redis没有事务这一步骤，没有回滚操作，因此无需写前日志。

#### 11.AOF的三种写盘策略
 1) always：每个操作日志都落盘
 2) everysec：每秒写盘
 3) No：由OS决定何时将日志从内存写到磁盘 

#### 12.有了AOF，redis就可以保证突然宕机时，数据完全不丢失吗？
 并不会，因为即便采用了always策略，在执行完操作后还没来得及写盘时宕机，数据依旧可能会丢失。

#### 13.AOF重写机制解决了什么问题
 在未进行重写前，redis会对每个操作命令追加到日志文件尾部，随着时间越久，日志文件也越来越大，这就导致了在追加写时会变慢，且根据日志恢复时也会很耗时。
 而通过重写机制，目标是将同一个key多个操作命令进行合并，只将最终结果形成一条日志记录追加到AOF日志中。
 其过程是redis会fork出一个bg-rewrite-aof线程，同时会将数据库的快照copy给rewrite线程？？？
 https://time.geekbang.org/column/article/271754
  
#### 14.RDB如何保存数据库快照
 默认配置情况下，master线程会fork出一个bgsave线程，来保存t时刻的全量数据副本，t以后产生增量的数据用AOF日志记录。生产环境一般是定时用RDB做亏快照，
 然后在两次快照间隔中产生的增量数据，用AOF记录。
 ？？？如何拿到t时刻的数据库快照，每个key都有时间戳吗？

#### 15.Redis集群模式
 1) 主从方式，写操作时只调用master，master写入成功后会将数据同步给slave；读操作时客户端直接访问slave

#### 16.Redis主从同步如何保证节点间的一致性
 1) 主从建立连接，协商同步
 2) 主fork出bgsave后台线程，将全量数据以rdb格式发送给从节点，与此同时记录下增量数据
 3) 从节点清空数据库，然后接到主的rdb文件后重建数据，重建完成后主节点陆续将新产生的增量数据发送给从节点，至此同步完成。

#### 17.主从同步时，如果slave很多如何降低master压力
 采用主-从-从机制，让新增的slave挂载到已经同步完成的slave上即可。

#### 18.主从同步数据文件采用RDB格式，而非AOF原因
 RDB是二进制文件，存储文件相对AOF较小，方便带宽传输，且相比AOF回放日志而言，RDB还原速度更快。
 
#### 19.如果master宕了怎么办
 redis的哨兵机制，可以保证重新选出master节点，整个选举信任master一般经历下面3个步骤：
 1) 判定：在master正常时，哨兵集群会向其定时发送弹活包，一旦master挂掉时，哨兵也会第一时间感知到。此时哨兵会发起下线仲裁，给其他哨兵发送is-master-down-by-addr命令，征询投票结果，票数过半认定节点失效。
 2) 选举：选举规则，优先排除掉网络不好的slave节点；然后将剩余的slave节点，根据优先级、主从数据复制进度（各个slave之间比对数据版本号），还有id大小进行打分。
 3) 通知：通知其他客户端master已经重新选举。

#### 20.哨兵集群多数实例达成共识，判断出主库“客观下线”后，由哪个实例来执行主从切换呢？
 哨兵集群判断出主库“主观下线”后，会选出一个“哨兵领导者”，之后整个过程由它来完成主从切换。
 但是如何选出“哨兵领导者”？这个问题也是一个分布式系统中的问题，就是我们经常听说的共识算法，指的是集群中多个节点如何就一个问题达成共识。共识算法有很多种，例如Paxos、Raft，这里哨兵集群采用的类似于Raft的共识算法。
 简单来说就是每个哨兵设置一个随机超时时间（增加扰动因子的目的是避免哨兵都立刻给自己投票，导致无法投票给其他人），超时后每个哨兵会请求其他哨兵为自己投票，其他哨兵节点对收到的第一个请求进行投票确认，一轮投票下来后，首先达到多数选票的哨兵节点成为“哨兵领导者”，如果没有达到多数选票的哨兵节点，那么会重新选举，直到能够成功选出“哨兵领导者”。
  
#### 21.redis的哨兵之间是如何进行协作的
 哨兵之间的协作，是通过master的发布订阅来进行通信的（master上会存在"__sentinel__:hello"的频道）。
 当哨兵上线后，通过给master发送info命令，来获取到slave节点信息，然后与slave建立连接并定时弹活。
  
#### 22.在选用Redis存储架构（单实例，分片存储），应该考虑到哪些因素
 1.因素1：部署成本（单实例部署简单，分片部署复杂）
 2.因素2：数据量大小（单机可承受20G，30G还能接受；如果考虑几百G只能用分片存储）
 3.因素3：与落盘方案有关（单机数据量过大时，落盘效率会很低，容易阻塞master线程）
 4.因素4：易扩展（如果初期定位存的数据后续可能会大规模增长，单机就不并不合适）
   
#### 23.redis在分片后数据如何分布
 redis会先将16384个slot平均分布在实例节点上，然后通过命令的key做hash计算，将结果对节点数量取模，判断应该落在哪个实例上

#### 24.如果分片变动，客户端怎么感知节点上的slot变更
 redis-cluster提供了重定向机制，即客户端在访问实例时如果没有数据，则会接到一个ask/move命令，告知重定向到其他实例取获取数据。
 ask命令代表正在迁移中；move代表已经迁移完成。

#### 25.如果需要存k-v数据，且k-v都是小于8字节的字符串，直接用sds存储有什么问题，该怎么存储才能节省空间；如果k-v是10个字节，怎么存储？
 直接使用sds存储字符串会导致空间浪费，redis的sds存储结构分为4部分：
   1.len：已使用长度
   2.alloc：已分配长度
   3.flags：标志位（0-4代表5中类型，分别代表长度为5、8、16、32、64，这5种长度的sds）
   4.buffer：内存存储数组
 （？？？待补充）

#### 26.redis的sds为什么要使用内存“不”对齐（？？？待补充）


#### 27.有一亿个keys要统计，应该用哪种集合？

#### 28.应用场景&redis类型
 1.商品对应评论的关系：可以用list存储
 2.排行榜、最新列表：可以用sortedset存储
 3.统计用户留存率：用list结构存储每天访问用户，计算留存率最好在redis的client端计算
 4.记录用户打卡
 
#### Redis的一些坑
 1.主从数据不一致
  原因：因为网络原因，slave延迟收到了master的消息；或者slave收到了一条复杂度高的命令，由于执行时间慢，导致未执行完期间主从不一致。
  解决方案：可以增加监控节点，使用info.master_repl_offset和info.slave_repl_offset读取master和slave的同步数据进度，两者差值达到一定阈值时，将slave从集群中摘除。
 2.主从部署时，读到了过期数据
  原因1：redis3.2版本之前存在一个bug，因为惰性删除的机制，只有当发生read时才会判断key是否过期，而读请求发生在slave节点，即便slave判断过期，因为无法写权限因此无法删除，而是读到了过期的数据。
  解决方案1：升级到redis3.2以上，slave上的过期数据会返回null
  原因2：redis3.2版本以上仍然有可能发生这种情况，是因为在新增key时，使用expire命令因主从延迟导致，例如expired [key] 60s，master收到请求时是9:00，而同步给slave的发生时间是9:01，这样主从就有1分钟的延迟
  解决方案2：使用expire_at命令代替expire
	
#### Redis对事务的支持
 1.在命令正确的前提下，redis能保证事务的原子性、一致性和隔离性（配合watch命令），但无法完整的保证持久性。
 2.redis事务相关的命令：multi、exec、discard
 3.redis执行事务的原理：redis实例会为每个连接保留一个单独的事务队列，当收到客户端传入的multi命令时，会将后续所有的命令暂存到一个queue中，然后等执行exec时提交事务；如果收到了discard，则清空queue而丢弃事务。
   需要注意的是，在exec命令执行过程中，如果其中一条命令执行失败，不会导致其他命令回滚，这时候无法保证原子性（但实际场景中，只要保证语法正确，redis写操作一般不会失败）。

#### Redis的几种场景
【数据不一致】写数据时开启事务，先写db，再写redis，全部成功后提交事务来保证两侧数据一致性。
【雪崩】大量的key突然过期，导致请求全部传入到数据库；解决办法：通过给key增加扰动时间避免。
【缓存穿透】redis的热点数据突然失效，导致访问该热点key的请求全部传入到数据库；解决办法：热点key不设置过期时间。
【缓存击穿】访问的key既不在cache中也不在db中，导致请求全部穿入到数据库中；解决办法：可以通过给key缓存nil值来避免击穿数据库。






  
  
  
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 