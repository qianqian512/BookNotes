#### 1.面对小段或大段数据，采用什么样的内存分配器

#### 2.redis 的rehash过程
 1) 给哈希表2分配更大的空间，例如是当前哈希表 1 大小的两倍；
 2) 把哈希表1中的数据重新映射并拷贝到哈希表 2 中；
 3) 释放哈希表1的空间。
 4) 采用渐进式迁移，避免主线程阻塞。

#### 3.redis底层数据结构对比
 sds
 双向链表
 压缩链表
 哈希表
 调表
 整数数组

#### 4.redis数据类型和底层结构对应关系(什么时候会进行底层数据结构转换)
 String - sds
 List - 双向链表，压缩链表
 Hash - 压缩链表，哈希表
 SortedSet - 压缩列表，调表
 Set - 哈希表，整数数组
 
#### 5.整数数组和压缩列表在查找上优势并不大，为什么还需要呢？
 1) 内存利用率更高
 2) 对CPU高速缓存更加友好，小数据量时CPU在随即读取时，会一次性将一段连续内存读入到高速缓存，一般一个缓存行是64字节，对整数数组而言，如果只有16个以内，基本也可以认为是O(1)读取
 
#### 6.redis单线程为什么快
 1) 对redis而言都是基于内存操作，因此单线程不仅不存在阻塞的情况，而且海避免了多线程之间竞争的开销。
 2) 另一方面redis单线程采用多路复用的NIO线程模型

#### 7.redis的线程模型
 1) 主线程：NIO
 2) 后台线程:AOF线程，expired线程
 
#### 8.Redis 6.0 中提出了多线程模型是什么样的？

#### 9.Redis单线程处理IO请求性能瓶颈
 存在慢查询操作会阻塞master线程，导致整个server吞吐量下降
  1) 写入或删除一个big key在分配或释放内存时会消耗更多的时间(big value不会吗)
  2) 使用复杂度比较高的命令，
  3?) 大量key集中过期：由于redis的过期删除机制，也是由master线程完成的(另一汇回答：大量的 key 过期并不会导致 redis 主线程阻塞。redis 是使用 lazy 以及后台周期采样删除的机制淘汰过期 key)
  4) 淘汰策略：淘汰策略也是由master线程完成的，当内存达到上限后，每次写操作都要进行淘汰删除一些key，也会降低redis吞吐量
  5?) AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 
  6?) 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
 并发量非常大时，redis在反序列化客户端请求时，无法利用多CPU特性，redis6.0推出了在对客户端数据编解码时，采用多线程方式，而命令操作时在内存中依旧是单线程。

#### 10.Redis为什么采用写后日志(AOF)，相比mysql的写前日志(WAL)，应用场景有什么不同？
 写后日志的好处：先执行成功再写日志，不会阻塞当前线程写操作
 写前日志的优势：mysql使用 redo Log + binLog 二阶段提交(prepare + commited),保证已提交的数据不会丢失，保证事务和一致性。

#### 11.AOF的三种写盘策略
 1) always：每个操作日志都落盘
 2) everysec：每秒写盘
 3) No：由OS决定何时将日志从内存写到磁盘 

#### 12.有了AOF，redis就可以保证突然宕机时，数据完全不丢失吗？
 并不会，因为即便采用了always策略，在执行完操作后还没来得及写盘时宕机，数据依旧可能会丢失。

#### 13.AOF重写机制解决了什么问题
 在未进行重写前，redis会对每个操作命令追加到日志文件尾部，随着时间越久，日志文件也越来越大，这就导致了在追加写时会变慢，且根据日志恢复时也会很耗时。
 而通过重写机制，目标是将同一个key多个操作命令进行合并，只将最终结果形成一条日志记录追加到AOF日志中。
 其过程是redis会fork出一个bg-rewrite-aof线程，同时会将数据库的快照copy给rewrite线程？？？
 https://time.geekbang.org/column/article/271754
  
  
  
  
  
  
  
  
  
  
  
   
 
 
 
 