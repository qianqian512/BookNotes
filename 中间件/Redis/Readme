#### 1.面对小段或大段数据，采用什么样的内存分配器

#### 2.redis 的rehash过程
 1) 给哈希表2分配更大的空间，例如是当前哈希表 1 大小的两倍；
 2) 把哈希表1中的数据重新映射并拷贝到哈希表 2 中；
 3) 释放哈希表1的空间。
 4) 采用渐进式迁移，避免主线程阻塞。

#### 3.redis底层数据结构对比
 sds
 双向链表
 压缩链表
 哈希表
 调表
 整数数组

#### 4.redis数据类型和底层结构对应关系(什么时候会进行底层数据结构转换)
 String - sds
 List - 线性数组 - 双向链表，压缩列表
 Hash - k-v存储 - 压缩列表，哈希表
 SortedSet - 有序集合 - 压缩列表，跳表
 Set - 不能重复集合 - 哈希表，整数数组
 
#### 5.整数数组和压缩列表在查找上优势并不大，为什么还需要呢？
 1) 内存利用率更高
 2) 对CPU高速缓存更加友好，小数据量时CPU在随即读取时，会一次性将一段连续内存读入到高速缓存，一般一个缓存行是64字节，对整数数组而言，如果只有16个以内，基本也可以认为是O(1)读取
 
#### 6.redis单线程为什么快
 1) 对redis而言都是基于内存操作，因此单线程不仅不存在阻塞的情况，而且海避免了多线程之间竞争的开销。
 2) 另一方面redis单线程采用多路复用的NIO线程模型

#### 7.redis的线程模型
 1) 主线程：NIO（待整理）
 2) 后台线程:AOF线程，expired线程
 
#### 8.Redis 6.0 中提出了多线程模型是什么样的？
 待确认？？？ 6.0之前版本，主线程既负责编解码，又负责执行操作命令；6.0后的版本，应该是将线程分为了编解码线程集合和工作线程，其中编解码线程集合负责对redis传入的数据命令行进行序列化反序列化操作；而工作线程仍然是单线程，只负责执行redis指令。

#### 9.Redis单线程处理IO请求性能瓶颈
 存在慢查询操作会阻塞master线程，导致整个server吞吐量下降
  1) 写入或删除一个big key在分配或释放内存时会消耗更多的时间(big value不会吗)
  2) 使用复杂度比较高的命令，
  3?) 大量key集中过期：由于redis的过期删除机制，也是由master线程完成的(另一汇回答：大量的 key 过期并不会导致 redis 主线程阻塞。redis 是使用 lazy 以及后台周期采样删除的机制淘汰过期 key)
  4) 淘汰策略：淘汰策略也是由master线程完成的，当内存达到上限后，每次写操作都要进行淘汰删除一些key，也会降低redis吞吐量
  5?) AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 
  6?) 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
 并发量非常大时，redis在反序列化客户端请求时，无法利用多CPU特性，redis6.0推出了在对客户端数据编解码时，采用多线程方式，而命令操作时在内存中依旧是单线程。

#### 10.Redis在将数据落盘时为什么采用写后日志(AOF)，相比mysql的写前日志(WAL)，应用场景有什么不同？
 写后日志的好处：先执行成功再写日志，不会阻塞当前线程写操作
 写前日志的优势：mysql使用 redo Log + binLog 二阶段提交(prepare + commited),保证已提交的数据不会丢失，保证事务和一致性，而redis没有事务这一步骤，没有回滚操作，因此无需写前日志。

#### 11.AOF的三种写盘策略
 1) always：每个操作日志都落盘
 2) everysec：每秒写盘
 3) No：由OS决定何时将日志从内存写到磁盘 

#### 12.有了AOF，redis就可以保证突然宕机时，数据完全不丢失吗？
 并不会，因为即便采用了always策略，在执行完操作后还没来得及写盘时宕机，数据依旧可能会丢失。

#### 13.AOF重写机制解决了什么问题
 在未进行重写前，redis会对每个操作命令追加到日志文件尾部，随着时间越久，日志文件也越来越大，这就导致了在追加写时会变慢，且根据日志恢复时也会很耗时。
 而通过重写机制，目标是将同一个key多个操作命令进行合并，只将最终结果形成一条日志记录追加到AOF日志中。
 其过程是redis会fork出一个bg-rewrite-aof线程，同时会将数据库的快照copy给rewrite线程？？？
 https://time.geekbang.org/column/article/271754
  
#### 14.RDB如何保存数据库快照
 默认配置情况下，master线程会fork出一个bgsave线程，来保存t时刻的全量数据副本，t以后产生增量的数据用AOF日志记录。生产环境一般是定时用RDB做亏快照，
 然后在两次快照间隔中产生的增量数据，用AOF记录。
 ？？？如何拿到t时刻的数据库快照，每个key都有时间戳吗？

#### 15.Redis集群模式
 1) 主从方式，写操作时只调用master，master写入成功后会将数据同步给slave；读操作时客户端直接访问slave

#### 16.Redis主从同步如何保证节点间的一致性
 1) 主从建立连接，协商同步
 2) 主fork出bgsave后台线程，将全量数据以rdb格式发送给从节点，与此同时记录下增量数据
 3) 从节点清空数据库，然后接到主的rdb文件后重建数据，重建完成后主节点陆续将新产生的增量数据发送给从节点，至此同步完成。

#### 17.主从同步时，如果slave很多如何降低master压力
 采用主-从-从机制，让新增的slave挂载到已经同步完成的slave上即可。

#### 18.主从同步数据文件采用RDB格式，而非AOF原因
 RDB是二进制文件，存储文件相对AOF较小，方便带宽传输，且相比AOF回放日志而言，RDB还原速度更快。
 
### 19.Redis的master宕机后如何保证高可用
 1.Redis通过哨兵机制保证了数据节点的高可用。在集群启动阶段，哨兵集群会对每个数据节点建立连接。
 2.在获得所有Redis数据节点后，哨兵集群会对每个数据节点建立长连接，并定时发送心跳（默认1s）；与此同时哨兵集群之间为了保证自身的高可用，哨兵节点之间也建立了长连接，并定时探活。
 3.当master面对哨兵发的心跳无回应时，哨兵会先将节点判定为主观下线。
 4.为了确认master节点是否真实下线，哨兵集群采用raft算法来共识master节点是否下线，当投票超过半数时，则判定为客观下线。
 5.确定master节点不可用后，哨兵集群中通过raft算法选举出一个leader来执行master的故障转移流程。
 6.新选举出的哨兵leader会从slave节点中选举出一个最优（根据配置的优先级、数据版本、ID自然排序）节点，晋升为master，并告知其他slave重新关联master节点。
 
【补充】如果后续old-master重新上线，此时只能当slave
【补充】哨兵是通过什么方式获得到slave节点信息的；哨兵集群是通过什么方式感知到彼此存在？
   1.哨兵只配置了master节点的ip，slave节点的IP是通过info查询master获取的，这样slave配置只要存在于master即可，不用配置在2个地方。
   2.一个集群内的哨兵信息，会配置同一个master，然后利用发布订阅功能监听一个哨兵专属的topic，来获得其他其他哨兵节点IP。
【思考】在主从架构中，如果master节点变更后，客户端如何感知？
  在主备架构中还好，客户端只配置了master的域名，因此master变更后客户端不需要感知；
  但在主从架构中，客户端需要同事配置master和slave的域名，此时节点信息发生改变，客户端怎么感知？难道也需要通知到客户端变更吗？或者redis网管改变路由信息？ 

### 20.Redis哨兵如何保证自身可用性
 1.集群角度：哨兵之间也建立了长连接，并定时进行探活，而且一旦发现某哨兵节点不可用，也会和集群内其他节点进行共识将其下线。
 2.哨兵自身角度：Redis哨兵通过TILT机制实现了内部自检流程，当诊断自己有问题时，会进入自我保护模式，进入保护模式的哨兵就不在参与投票。
 
【TILT模式】
 Redis的哨兵在判定节点是否存活时，其实时严重依赖系统时间的，通过计算ping-pong的往返时间来完成的判定流程。而哨兵内部的定时任务执行时间过长或阻塞时，就会自我诊断进入TILT模式。
 因为在正常情况下，哨兵内部的定时任务是不会有阻塞发生的，如果两次执行时长出现过长或未负数(负数情况一般时系统时间被篡改)时，那么说明这个哨兵所处的网络不稳定或有其他问题，需要运维人工干预。

### 21.Redis哨兵发生脑裂怎么办
 Redis哨兵之间达成共识采用的是raft算法，通过多数派达成一致解决了脑裂问题。但极端情况下如果脑裂过于严重，以至于没有任何一个小集群能达到多数派，那么整个集群彻底不可用，例如9个节点，裂变出数量3-3-3的3个集群，那么此时哨兵集群也不可用。 
  
#### 22.在选用Redis存储架构（单实例，分片存储），应该考虑到哪些因素
 1.因素1：部署成本（单实例部署简单，分片部署复杂）
 2.因素2：数据量大小（单机可承受20G，30G还能接受；如果考虑几百G只能用分片存储）
 3.因素3：与落盘方案有关（单机数据量过大时，落盘效率会很低，容易阻塞master线程）
 4.因素4：易扩展（如果初期定位存的数据后续可能会大规模增长，单机就不并不合适）
   
#### 23.redis在分片后数据如何分布
 redis会先将16384个slot平均分布在实例节点上，然后通过命令的key做hash计算，将结果对节点数量取模，判断应该落在哪个实例上

#### 24.如果分片变动，客户端怎么感知节点上的slot变更
 redis-cluster提供了重定向机制，即客户端在访问实例时如果没有数据，则会接到一个ask/move命令，告知重定向到其他实例取获取数据。
 ask命令代表正在迁移中；move代表已经迁移完成。

#### 25.如果需要存k-v数据，且k-v都是小于8字节的字符串，直接用sds存储有什么问题，该怎么存储才能节省空间；如果k-v是10个字节，怎么存储？
 直接使用sds存储字符串会导致空间浪费，redis的sds存储结构分为4部分：
   1.len：已使用长度
   2.alloc：已分配长度
   3.flags：标志位（0-4代表5中类型，分别代表长度为5、8、16、32、64，这5种长度的sds）
   4.buffer：内存存储数组
 （？？？待补充）

#### 26.redis的sds为什么要使用内存“不”对齐（？？？待补充）


#### 27.有一亿个keys要统计，应该用哪种集合？

#### 28.应用场景&redis类型
 1.商品对应评论的关系：可以用list存储
 2.排行榜、最新列表：可以用sortedset存储
 3.统计用户留存率：用list结构存储每天访问用户，计算留存率最好在redis的client端计算
 4.记录用户打卡
 
#### Redis的一些坑
 1.主从数据不一致
  原因：因为网络原因，slave延迟收到了master的消息；或者slave收到了一条复杂度高的命令，由于执行时间慢，导致未执行完期间主从不一致。
  解决方案：可以增加监控节点，使用info.master_repl_offset和info.slave_repl_offset读取master和slave的同步数据进度，两者差值达到一定阈值时，将slave从集群中摘除。
 2.主从部署时，读到了过期数据
  原因1：redis3.2版本之前存在一个bug，因为惰性删除的机制，只有当发生read时才会判断key是否过期，而读请求发生在slave节点，即便slave判断过期，因为无法写权限因此无法删除，而是读到了过期的数据。
  解决方案1：升级到redis3.2以上，slave上的过期数据会返回null
  原因2：redis3.2版本以上仍然有可能发生这种情况，是因为在新增key时，使用expire命令因主从延迟导致，例如expired [key] 60s，master收到请求时是9:00，而同步给slave的发生时间是9:01，这样主从就有1分钟的延迟
  解决方案2：使用expire_at命令代替expire
	
#### Redis对事务的支持
 1.在命令正确的前提下，redis能保证事务的原子性、一致性和隔离性（配合watch命令），但无法完整的保证持久性。
 2.redis事务相关的命令：multi、exec、discard
 3.redis执行事务的原理：redis实例会为每个连接保留一个单独的事务队列，当收到客户端传入的multi命令时，会将后续所有的命令暂存到一个queue中，然后等执行exec时提交事务；如果收到了discard，则清空queue而丢弃事务。
   需要注意的是，在exec命令执行过程中，如果其中一条命令执行失败，不会导致其他命令回滚，这时候无法保证原子性（但实际场景中，只要保证语法正确，redis写操作一般不会失败）。

#### Redis的几种场景
【数据不一致】写数据时开启事务，先写db，再写redis，全部成功后提交事务来保证两侧数据一致性。
【雪崩】大量的key突然过期，导致请求全部传入到数据库；解决办法：通过给key增加扰动时间避免。
【缓存穿透】redis的热点数据突然失效，导致访问该热点key的请求全部传入到数据库；解决办法：热点key不设置过期时间。
【缓存击穿】访问的key既不在cache中也不在db中，导致请求全部穿入到数据库中；解决办法：可以通过给key缓存nil值来避免击穿数据库。



#### Redis集群方案

#### Redis使用经典场景的案例
 1.商品对应评论的关系：可以用list存储
 2.排行榜、最新列表：可以用sortedset存储
 3.统计不同页面的UV：用set存储每个用户的id，统计时直接用scard
 4.记录用户打卡

#### 对比Redis作为消息队列和其他消息队列的差异
 1.实时性：满足
 2.功能性：redis5.0的Stream数据结构满足了消息分组的要求
 3.顺序性：在5.0之前，可以用list数据结构保证顺序性;5.0之后Stream可以保证顺序性
 4.消息重复：由消费者自己判断是否重复消费
 5.消息可靠性：不满足，redis的消息没有队列，订阅者不在线期间产生的消息会全部丢弃。
 
#### 哪些操作可能会影响到Redis阻塞
 1.写入或删除一个big key在分配或释放内存时会消耗更多的时间(big value不会吗)
 2.复杂度较高的命令，例如2个大list取交集
 3.淘汰策略：淘汰策略也是由master线程完成的，当内存达到上限后，每次写操作都要进行淘汰删除一些key，也会降低redis吞吐量
 4.AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 
 5.主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
 6.并发量非常大时，redis在反序列化客户端请求时，无法利用多CPU特性，redis6.0推出了在对客户端数据编解码时，采用多线程方式，而命令操作时在内存中依旧是单线程。
 


  
  
  
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
