#### 1.面对小段或大段数据，采用什么样的内存分配器

#### 2.redis 的rehash过程
 1) 给哈希表2分配更大的空间，例如是当前哈希表 1 大小的两倍；
 2) 把哈希表1中的数据重新映射并拷贝到哈希表 2 中；
 3) 释放哈希表1的空间。
 4) 采用渐进式迁移，避免主线程阻塞。

#### 3.redis底层数据结构对比
 sds
 双向链表
 压缩链表
 哈希表
 调表
 整数数组

#### 4.redis数据类型和底层结构对应关系(什么时候会进行底层数据结构转换)
 String - sds
 List - 双向链表，压缩链表
 Hash - 压缩链表，哈希表
 SortedSet - 压缩列表，调表
 Set - 哈希表，整数数组
 
#### 5.整数数组和压缩列表在查找上优势并不大，为什么还需要呢？
 1) 内存利用率更高
 2) 对CPU高速缓存更加友好，小数据量时CPU在随即读取时，会一次性将一段连续内存读入到高速缓存，一般一个缓存行是64字节，对整数数组而言，如果只有16个以内，基本也可以认为是O(1)读取
 
#### 6.redis单线程为什么快
 1) 对redis而言都是基于内存操作，因此单线程不仅不存在阻塞的情况，而且海避免了多线程之间竞争的开销。
 2) 另一方面redis单线程采用多路复用的NIO线程模型

#### 7.redis的线程模型
 1) 主线程：NIO（待整理）
 2) 后台线程:AOF线程，expired线程
 
#### 8.Redis 6.0 中提出了多线程模型是什么样的？
 待确认？？？ 6.0之前版本，主线程既负责编解码，又负责执行操作命令；6.0后的版本，应该是将线程分为了编解码线程集合和工作线程，其中编解码线程集合负责对redis传入的数据命令行进行序列化反序列化操作；而工作线程仍然是单线程，只负责执行redis指令。

#### 9.Redis单线程处理IO请求性能瓶颈
 存在慢查询操作会阻塞master线程，导致整个server吞吐量下降
  1) 写入或删除一个big key在分配或释放内存时会消耗更多的时间(big value不会吗)
  2) 使用复杂度比较高的命令，
  3?) 大量key集中过期：由于redis的过期删除机制，也是由master线程完成的(另一汇回答：大量的 key 过期并不会导致 redis 主线程阻塞。redis 是使用 lazy 以及后台周期采样删除的机制淘汰过期 key)
  4) 淘汰策略：淘汰策略也是由master线程完成的，当内存达到上限后，每次写操作都要进行淘汰删除一些key，也会降低redis吞吐量
  5?) AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能； 
  6?) 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；
 并发量非常大时，redis在反序列化客户端请求时，无法利用多CPU特性，redis6.0推出了在对客户端数据编解码时，采用多线程方式，而命令操作时在内存中依旧是单线程。

#### 10.Redis在将数据落盘时为什么采用写后日志(AOF)，相比mysql的写前日志(WAL)，应用场景有什么不同？
 写后日志的好处：先执行成功再写日志，不会阻塞当前线程写操作
 写前日志的优势：mysql使用 redo Log + binLog 二阶段提交(prepare + commited),保证已提交的数据不会丢失，保证事务和一致性，而redis没有事务这一步骤，没有回滚操作，因此无需写前日志。

#### 11.AOF的三种写盘策略
 1) always：每个操作日志都落盘
 2) everysec：每秒写盘
 3) No：由OS决定何时将日志从内存写到磁盘 

#### 12.有了AOF，redis就可以保证突然宕机时，数据完全不丢失吗？
 并不会，因为即便采用了always策略，在执行完操作后还没来得及写盘时宕机，数据依旧可能会丢失。

#### 13.AOF重写机制解决了什么问题
 在未进行重写前，redis会对每个操作命令追加到日志文件尾部，随着时间越久，日志文件也越来越大，这就导致了在追加写时会变慢，且根据日志恢复时也会很耗时。
 而通过重写机制，目标是将同一个key多个操作命令进行合并，只将最终结果形成一条日志记录追加到AOF日志中。
 其过程是redis会fork出一个bg-rewrite-aof线程，同时会将数据库的快照copy给rewrite线程？？？
 https://time.geekbang.org/column/article/271754
  
#### 14.RDB如何保存数据库快照
 默认配置情况下，master线程会fork出一个bgsave线程，来保存t时刻的全量数据副本，t以后产生增量的数据用AOF日志记录。生产环境一般是定时用RDB做亏快照，
 然后在两次快照间隔中产生的增量数据，用AOF记录。
 ？？？如何拿到t时刻的数据库快照，每个key都有时间戳吗？

#### 15.Redis集群模式
 1) 主从方式，写操作时只调用master，master写入成功后会将数据同步给slave；读操作时客户端直接访问slave

#### 16.Redis主从同步如何保证节点间的一致性
 1) 主从建立连接，协商同步
 2) 主fork出bgsave后台线程，将全量数据以rdb格式发送给从节点，与此同时记录下增量数据
 3) 从节点清空数据库，然后接到主的rdb文件后重建数据，重建完成后主节点陆续将新产生的增量数据发送给从节点，至此同步完成。

#### 17.主从同步时，如果slave很多如何降低master压力
 采用主-从-从机制，让新增的slave挂载到已经同步完成的slave上即可。

#### 18.主从同步数据文件采用RDB格式，而非AOF原因
 RDB是二进制文件，存储文件相对AOF较小，方便带宽传输，且相比AOF回放日志而言，RDB还原速度更快。
 
#### 19.如果master宕了怎么办
 redis的哨兵机制，可以保证重新选出master节点，整个选举信任master一般经历下面3个步骤：
 1) 判定：在master正常时，哨兵集群会向其定时发送弹活包，一旦master挂掉时，哨兵也会第一时间感知到（一般高可用的redis哨兵也是以集群方式存在，防止单点哨兵网络不好形成误判）
 2) 选举：选举规则，优先排除掉网络不好的slave节点；然后将剩余的slave节点，根据优先级、主从数据复制进度（各个slave之间比对数据版本号），还有id大小进行打分。
 3) 通知：通知其他客户端master已经重新选举。

#### 20.哨兵集群多数实例达成共识，判断出主库“客观下线”后，由哪个实例来执行主从切换呢？(难道不是由新任master来执行切换吗，主从切换都要做哪些事情？？？)
 哨兵集群判断出主库“主观下线”后，会选出一个“哨兵领导者”，之后整个过程由它来完成主从切换。
 但是如何选出“哨兵领导者”？这个问题也是一个分布式系统中的问题，就是我们经常听说的共识算法，指的是集群中多个节点如何就一个问题达成共识。共识算法有很多种，例如Paxos、Raft，这里哨兵集群采用的类似于Raft的共识算法。
 简单来说就是每个哨兵设置一个随机超时时间，超时后每个哨兵会请求其他哨兵为自己投票，其他哨兵节点对收到的第一个请求进行投票确认，一轮投票下来后，首先达到多数选票的哨兵节点成为“哨兵领导者”，如果没有达到多数选票的哨兵节点，那么会重新选举，直到能够成功选出“哨兵领导者”。
  
#### 21.redis的哨兵之间是如何进行协作的
 
  
  
  
  
  
  
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 