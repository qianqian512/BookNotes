##基础篇

### Redis的数据类型和底层存储结构对应关系
  #### 简单动态字符串-SDS
	What：Redis内置字符串数据结构，是Redis String类型对应的存储结构。
	Why：C语言中的字符串和Java中的类似，是一种不支持修改的数据结构，而Redis需要的字符串恰恰是需要允许修改的。
	Where：SDS最常见的使用场景就是作为redis的key使用；AOF缓冲区；客户端的输入缓冲区。
	* 优点：获取字符串长度是O(1)复杂度；减少频繁修改而导致多次扩容（SDS扩容的分水岭在1M临界点：1M内每次2倍扩容；超过1M每次以1M速度扩容）；惰性释放（SDS在修改后的空余位置不会立即回收，这不确定算是缺点还是优点）
	sdshdr {
	  free : 剩余可用字节长度,
	  len : 字符数组长度,
	  buf : 字符数组
	}
   【思考】redis为什么不沿用c的原生数组
   	  1) 考虑redis中的字符串频繁修改的可能性更高一些，因此记录了字符串的len和free可以快速的判断是在原地修改还是需要分配新的空间。
   	  2) redis的sds使用了len和free，存储使用字节数组，所以面向的数据格式更加广泛，可以存储包含任意二进制数据格式。
   【思考】redis的sds既然用了len和free表示长度，为什么还要用\0作为末尾分隔符
   	  猜测应该主要是为了兼容c的api，所以遵循了原有c的格式。
  #### 链表-linkedlist
    What: Redis中的链表是一个双向无环链表。
    Where: 链表作为List类型的底层存储结构之一，在数据存储达到一定规模后底层结构由ziplist转成linkedlist。
    list {
       head *listNode : 头节点
       tail *listNode : 尾节点
       len : 链表长度
    }
    listNode {
       prev : 前驱节点
       next : 后继节点
       value : 链表值
    }
   【思考】对比redis中List类型使用线性表和链表的优缺点
   		线性表虽然随机读很快，写性能较低，尤其插入或删除操作导致链表大量的数据发生移动来添补空间碎片；且一般连续分配，内存利用率高。
   		链表插入和删除都很快，O(1)复杂度；在读取头和尾时也能达到O(1)时间复杂度，但每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效。且存每个节点数据较小时，额外存储前驱和后继节点对空间有些浪费。
  #### 字典结构-dict
	What：最基本的k-v结构，
	Where：Redis中的dict结构应用非常广泛，例如redis数据库就是采用hash结构实现的，最常见的set就是将一组k-v塞到了hash中；还有Hash数据类型在数据量达到一定阈值时也会从压缩列表演变成dict结构存储。
	dictht {
		table : 哈希表数组(dictEntry)
		size : 哈希表大小 
		sizemask : 掩码，用于计算hash值使用，总是恒等于size-1
		used : hash表已有节点数量
	}
	dictEntry {
		key : 键
		union {
			val : 值对象指针
			u64 : 有符号整型
			s64 : 无符号整型
		} // 值（根据value类型，选用里面3个字段中的一个使用）
		next : 发生hash冲突时，指向的下一个hash节点，最终冲突的节点形成链表。
	}
	dict {
		type : 类型函数，dict应用比较广泛，而dict本身是一个抽象模型，因此对k-v的操作并没有在函数定义时强行限制，而是靠调用者传入从而更加灵活。
		privatedata : 配合type使用，负责存type所需的参数
		ht[2] : 这里是一个包含2个元素的hash数组，ht[0]是正在使用的hash，ht[1]一般是在rehash进行迁移时使用。
		trehashidx : rehash标识，等于-1时代表没有进行rehash操作
	}
	* Redis中的Hash结构什么时候进行扩容和收缩
	  满足一下任意一个时触发扩容条件：
	    1) 服务器没有BG-SAVE或BG-REWRITE-OF命令，Hash负载因子等于1时；
	    2) 服务器正在执行BG-SAVE或BG-REWRITE-OF命令，Hash负载因子等于5时；
	  其中负载因子计算公式：
	    load_factor = ht[0].used / ht[0].size;
	  另一方面，当负载因子小于0.1时，hash开始进行收缩操作。
	* 针对上面为什么BG-SAVE时，redis需要把load_factor阈值提高
	  为了避免redis主进程fork出的bg进程在使用copy-on-write时频繁的触page-fault。
	 【补充】copy-on-write计算原理：
	  1.在不适用copy-on-write技术时，父进程在fork子进程时，子进程会copy一份父进程的内存作为自己的存储空间，从此以后父子存储相互独立。
	  2.基于1的模式，现实中fork出的子进程往往和父进程做的工作不同，因此copy出父进程的内存快照没有任何用处，这里就需要引入exec命令集。
	  3.子进程要做自己想做的事情，就需要先装在必要的内存数据，因此exec函数的目的是：装在一个新的可执行程序覆盖原有内存，这样子进程调用完exec就可以做自己的要做的工作了。
	  4.经历完前面的1-2-3后发现，fork时子进程copy父进程的快照后但没有使用，属于浪费资源的操作，因此就引入了copy-on-write机制。
	  5.copy-on-write达到的目的是，fork出的子进程不会copy父进程快照，而是采用与父进程共享，但这段共享区域一旦发生写操作，子进程会立刻copy出一份副本来保持两方独立，互不干涉，这就是page-fault
	  6.因此在回过来看rehash操作与copy-on-write的影响，由于rehash肯定是发生在父进程上，虽然redis采用渐进式rehash，但还是不可避免的发生了更多的写操作，与fork出的bg子线程发生冲突，产生了过多
	    的page-fault，而写操作又不可避免，那么只能调整hash负载因子的阈值，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存（阈值调大后就不扩容了，也就不会因为rehash而进行渐进式迁移
	    了，不迁移了写操作就减少了）。
	* 渐进式Hash
	   为了避免一次性集中迁移导致master线程阻塞，Redis采用渐进式迁移。渐进式迁移发生的时机是，每次对key所在的下标进行读取或写入。最终将所有迁移工作，平摊到每个时间点上。
	   [补充] 在rehash过程中(rehashIdx不等于-1时)，由于key可能已经迁移或未迁移，因此在操作时也会在ht[0]和h1[1]上操作。
	【思考】hash是k-v类型，当底层用ziplist存储在查询时怎么保证效率？
	    hash类型在使用ziplist作为存储结构的一个前提是，当数据量不大是才满足使用。ziplist默认作为优先使用的存储结构，基本条件就是整个ziplist大小不会超过L1的大小，所以cpu在操作ziplist时完全可以
	    一次性的将整个list加载到cpu缓存行操作，因此在查询或修改，即便是连锁更新时也能保证效率。
	    [补充] ziplist使用条件：list节点数量不超过512，单节点占用空间不大于64，满打满算也就在30K上下，足够L1一次加载到缓存行。
	    
  #### 跳表（skiplist）
    What：跳表是一种有序的存储结构，是一种支持二分查找的链表结构，其内部通过维护一个多层的链表，且上层链表中的元素是下一层链表元素的子集，越往上则越稀疏。在搜索时，跳表则现在上层的稀疏链表中搜索，当节点值
         小于等于目标值时，则向下查找；如果节点值大于目标值，则继续在同层遍历向后查找。平均查找效率是O(logN)，最坏情况是O(n)，删除修改效率同查找，取决于find效率，而找到目标节点后，链表修改或删除复杂度是O(1)。
    Where：跳表在Redis中使用并不是非常广泛，仅在实现zset类型使用。
    
   【思考】Redis为什么不选用B+Tree来代替跳表？
		抛开两者的实现复杂度不提；Redis和MySQL数据存储介质不同，前者数据存在内存中，后者数据存储在硬盘里，而B+Tree主要是通过降低层高来减少访问磁盘次数，而Redis不涉及，所以选择了跳表。
   【注意】一般博客或书中给跳表图例，都是为了方便读者学习，画的一般都是完全跳表，结构工整，节点分布均匀。但实际的跳表算法是通过随机数生成层高，因此跳表每层结构可能也“凹凸有致”，而且数据规模越大的跳表，时间复杂度会越来稳定。
		
  #### 整数集合（intset）
    What：整数集合顾名思义，就是一个集合中的所有元素都是整数。底层用了一个int数组来升序保存着整型数值，其中int的长度取决于另一个字段encoding（int16/int32/int64），为了节省内存，在存储时尽可能用更小的int类型
         一旦新增元素超过存储边界，则整个int数组会进行一次大的升级，例如从int16->int32或者int16->int64。intset支持升级，但不支持降级（注意一点，intset的整型长度都是有符号类型）。
    Where：作为set类型的底层存储，当元素不多且集合内都是整型时使用。
    intset {
    	encoding : 编码方式 int16/int32/int64
    	length : contents中元素的数量
    	contents : 数组类型，用来存储整型数据
    }
   【Q1】intset是如何保证不重复的？
    	intset内部维护了一个从小到大的有序的数组，因此插入时会根据顺序的特性判断是否重复，但这样引入了一个新的问题就是插入和删除的效率问题。例如当插入一个较小元素时，会导致数组大部分元素都要后移，但好在intset仅在数据规模小
    	时作为底层存储结构，因此猜测这点损耗Redis应该是可以接受。
    
  #### 压缩列表（ziplist）
    What：压缩列表是为了界具有Redis内存而开发的一种独有的数据结构，可以理解为是一个动态类型节点的线性表，内部节点当长度/类型都是动态定义的。
  		ziplist {
  			zlbytes（4bytes）整个ziplist占用字节数，最多4G
  			ztail（4bytes）尾结点偏移量，通过这个偏移量可以快速的定位到tail
  			zllen（2bytes）当zllen<65536时代表ziplist中节点的数量；如果zllen=65535时，需要遍历整个ziplist才能计算出列表长度。
  			entry[]（不确定）
  			zlend（1bytes）0xFF 代表整个链表结束
  		}
  		zipnode {
  			 previous_entry_length（1～5bytes）存储了上一个节点的长度，当length值小于254时，则说明上个节点长度小于254字节；反之用后面4个字节来表示上个节点长度。这个节点主要用途是可以让整个链表从后向前遍历。
  			 encoding（1～5bytes）存储了content当类型，其中它的节点值类型支持大体可以分为2大类：
	    		1) 直接存储字节数组，存储的长度类型分为：
	    			【63字节】2的6次方 - 1			占用1字节，高2位存储类型(00)，低6位存储长度，最大长度是6个1
	    			【16383字节】2的14次方 - 1		占用2字节，第1个字节的高2位存储类型(01)，第1个字节的低6位+后1个字节存储长度，最大长度是14个1
	    			【42亿】2的32次方 - 1			占用5字节，第1个字节的高2位存储类型(10)，后4个字节存储长度，最大长度是4G
	    		2) 存储数字：
	    			【4位】有符号整数  	（0 ~ 12）
	    			【1字节】有符号整数		（0 ~ 255）
	    			【3字节】有符号整数		（0 ~ 65535*8）
	    			【int16】			（-3W ~ 3W）
	    			【int32】			（-21亿 ~ 21亿）
	    			【int64】			（略）
  			 content（不确定）配合encoding存储，存储值可能是int或字节数组。
		}
  	Where：ziplist作为Redis的3种数据类型的底层存储结构，其共同点都是仅单节点占用空间少，且列表总节点数量少时使用。
  	Why：ziplist虽然节省空间，但修改起来会比较麻烦，尤其是连锁更新时，如果整个联调过长，会导致更新非常耗时。另一方面，如果单个节点占用空间过大，有什么问题呢？
  	     学习完后面的内容，找到了这个问题的答案：ziplist定位就是小规模数据存储结构，因此需要保证整个list能被cpu的L1一次加载完全。根据redis的默认配置(单节点小于64字节)ziplist最大也就在30K上下，可以一次加载到L1中，如果单节点过大，就导致cpu和内存频繁交互，性能下降。
  	How：ziplist是怎么支持List、hash和SortedSet类型的？
  		 不同的数据类型通过约定节点的含义来区分，例如：
  		 a) List : 每个ZipNode就代表List中的一个元素；
  		 b) hash : 奇数Node代表key，偶数Node代表value，因此两个相邻的node构成了一组k-v节点。
  		 c) sortedset : 奇数Node代表value，偶数Node用来记录Score，因此两个相邻的node构成了一个sortedset节点。
  	
  【总结】对比ziplist和linkedlist
  	 	  发现ziplsit存储列表长度最少只要11字节，如果存的value在0～12之间，每个元素仅占用2个字节（1字节是prev_entry_len，另1个字节是encoding，content都省略了）
  	 	  而如果用linkedlist存储，list定义长度是16字节，每新增一个元素，光是记录前驱后继指针就要16个字节（64位操作系统一个指针占用8字节），value用最小的整型int16也是2个字节，因此相比下，和ziplist相差8倍。且linkedlist另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。
  	   
  【Q1】关于ziplist中node节点的encoding字段：
		记录了节点的类型，使用一个字节保存了9种类型，高2位非11开头的3中数值代表content存的是数组；而高2位11开头的代表存的整数数值。这里还有一个极致的空间压缩，当encoding的高4位是1111，
		但低4位不是0000和1110时，redis将0~12之间的value存储在低4位中，从而节省了content占用的空间，也就是说我们用的value是0~12之间的数字时，encoding既存了类型也存了value。
		
  【Q2】为什么不用链表代替列表呢？
  		猜测应该主要还是为了节省空间，对比linkedlist，光是一个node的前驱和后继就要占用8个字节，而ziplist最优情况下，每个节点仅占用2字节。且线性表的优势占用一片连续的空间可以很好的利用CPU缓存访问数据
  		
  【Q3】ziplist这种数据线性存储结构，插入数据时，数据怎么移动的？例如lpush这种命令？感觉时间复杂度会不会很高？
       学习完后面的内容，找到了这个问题的答案：ziplist定位就是小规模数据存储结构，因此需要保证整个list能被cpu的L1一次加载完全。根据redis的默认配置(单节点小于64字节)ziplist最大也就在30K上下，可以一次加载到L1中，因此整个数组即便是全量移动，在缓存行中也可以快速完成。
  	
  #### 快捷列表（quicklist）
    What：值类型是ziplist的linkedlist。
    Where：用于list类型的存储结构，在3.2以后已作为list结构的唯一实现，不再直接使用ziplist和linkedlist做转换。
    Why：Redis3.2之前的List类型底层用linkedlist和ziplist存储，在4.0后为什么使用quicklist？quicklist解决了什么问题？
    	a) linkedlist内存开销相对较大，除了要保存数据，还要保存前后节点的指针。并且每个节点是单独的内存块，容易造成内存碎片。
		b) ziplist是一块连续的内存，不用前后项指针，节省内存。但是当进行修改操作时，不仅会发生级联更新，而且同时会发生内存拷贝，性能开销较大。
		c) 而quicklist是一种基于空间和效率的折中方案
	How：quicklist是怎么对空间和性能进行折中的？
		a) 空间上：主要用于存储数据节点还是用过ziplist，而linkedlist只是将多个ziplist连接起来，大大的减少了前驱后继指针的数量。
		b) 性能上：quicklist将ziplist进行分段后，无论是在级联更新还是内存拷贝都只作用于子段，而不会导致全表进行联动。
		
  #### 对象（RedisObject）
    What：准确的说，Object并不能算作是Redis数据类型底层的一种存储结构，它更像是对下层实现的封装，屏蔽了下层数据结构的切换，并实现了通用的逻辑（例如引用计数，LRU记录等）。
    Where：anywhere
    Why：为什么要用RedisObject，引用RedisObject带来了什么好处？
      1.多态：对上层API封装了下层实现逻辑，屏蔽了下层多种数据结构的切换。
      2.内存释放：通过在RedisObject内部定义了refCount，可以通过引用计数方式实现垃圾回收。
      3.对象共享：在Redis中的key-value都是用Object包装，因此通过对象共享的方式可以极大的节省了内存空间。
        [补充1] Redis并不会对所有对象共享，而是仅能对包含整数值的字符串对象进行共享，原因是过于复杂的类型，在判断是否能共享时，要对每一个字节进行判断，导致时间复杂度过高影响效率。
        [补充2] Redis服务器在启动时默认会初始化int类型0~9999这1万个字符串对象，后续再引用0~9999时就可以直接复用，避免二次创建。
      4.对象空转时长：通过在RedisObject内部定义了lru字段，记录了该对象在最后一次被访问的时间，可以实现lru策略。
   【字符串对象】
      1.编码规则
   		a) 如果value是数字，则优先使用int存储
   		b) 如果value是字符，且长度小于39，则使用embstr存储
   		c) 如果上面2个规则都不满足，则使用raw存储。
   	    注意：embstr和raw虽然编码格式不同，但底层都是用sds存储。
   	  2.redis对字符串定义了sds，为什么又要使用一个embstr？
   	    a) 相比raw，embstr的定位是存储短字符串一种编码方式。因为value简短，所以对redisObject和embstr在分配或释放内存时只进行一次操作即可（raw因为空间不确定，所以是2次分配，2次分配的内存地址未必连续）
   	    b) embstr类型是readonly类型，因此对于一个embstr做了修改操作(例如append [key] [value])会发现encoding从embstr变成了raw】‘（redis为什么要这么设计？）
   	  3.字符串隐式支持浮点类型，例如执行以下操作命令：
   	    redis> set pi 3.14
   	   	ok
   	    redis> object encoding pi
   	    "embstr"
   	    redis> incrbyfloat pi
   	    "5.14"
   	    redis> object encoding pi
   	    "embstr"
   	    结论: 可以看到redis虽然用embstr存储了3.14，但在进行浮点自增时，会先将字符串转成float再做计算，从而支持了浮点自增操作。
   	     
   【列表对象】
   	   1.编码规则
    	a) 3.2版本以前，节点数量小于64 且 单节点占用小于512字节时 (大概就是30KB，这样足够CPU的L1一次加载到缓存行)时使用ziplist，反之使用linkedlist。
    	b) 3.2版本以后一直使用quicklist
       注意：节点数量小于64、单节点字节小于512B是可配置的
       
   【哈希对象】
   	   1.编码规则
    	节点数量小于512 且 单节点占用小于64字节时 (大概就是30KB，这样足够CPU的L1一次加载到缓存行)时使用ziplist，反之使用hash。
       注意：节点数量小于512、单节点字节小于64B是可配置的
       
   【集合对象】
       1.编码规则
        值全部都是int类型，且保存元素的数量小于512个时，使用intset；反之使用hash结构存储。
       注意：节点数量小于512是可以修改的
       
   【有序集合对象】
       1.编码规则
         元素数量小于128个，且但个节点占用空间小于64字节时，使用ziplist存储；反之使用zset存储(skiplist+hash的复合数据结构)
       2.SortedSet为什么要用zset这种符合数据结构？
         skplist保证了在range查询的效率；hash保证了在根据key查询score的O(1)效率
 
#### Redis的优化点
 1.ziplist中存储0~12数值，这种value应该非常常见，因此redis采用了比较极致的压缩手段。假如我们的场景是需要使用list类型存储大量的状态标识，那么这其中的value最好就选用0~12来存储。
 
#### 从Redis中学到了什么
 1.没有完美的数据结构，redis的经典数据结构也都是基于场景出发
 	a) ziplist的连锁更新复杂度会达到O(n²)。但好在场景并不多见；如果list长度不大，也没有问题。
 	b) intset在插入或删除靠前面的元素时，会导致后面元素都要跟着移动。但好在intset定位存储数据规模小
 2.redis采用引用计数方式实现了垃圾回收
    因为redis不像Java那样，对象之间存在循环引用的关系，Redis中至多就是用多个key共享一个对象，来达到节省内存空间。
 
 ## Redis命令篇
 #### 查看一个key底层使用的存储结构
  1) object encoding [key]
  2) debug object [key]
  3) type [key]
#### 查看引用计数
  object refcount [key]  
