二阶段提交中，如果在第一次询问阶段ok，但follower立刻挂掉了，怎么保证二阶段的提交。

raft不是一致性算法而是共识算法。
paxos是共识算法，或者叫一致性

raft是保证了一致性还是可用性。只能leader单点写是不是等同于牺牲了可用性。

raft是如何解决脑裂的问题。

raft通过二次提交实现的读是强一致性；
但是基于日志式的数据存储，读只能保证顺序一致性。

日志完整性高的跟随者（也就是最后一条日志项对应的任期编号值更大，索引号更大），拒绝投票给日志完整性低的候选人。比如节点 B 的任期编号为 3，节点 C 的任期编号是 4，节点 B 的最后一条日志项对应的任期编号为 3，而节点 C 为 2，那么当节点 C 请求节点 B 投票给自己时，节点 B 将拒绝投票

你可以把 Raft 的日志复制理解成一个优化后的二阶段提交（将二阶段优化成了一阶段），减少了一半的往返消息，也就是降低了一半的消息延迟。

raft中在脑裂场景出现两个leader时，客户端侧角度看是怎样的，有两个leader，会不会困惑，该怎么写？

raft协议在集群扩容时为什么要采用单节点变更策略。

在最后，我给你留了一个思考题，强领导者模型会限制集群的写性能，那你想想看，有什么办法能突破 Raft 集群的写性能瓶颈呢？

Raft 集群具有容错能力，能容忍少数的节点故障，那么在多个 Raft 集群组成的 KV 系统中，如何设计一致哈希，实现当某个集群的领导者节点出现故障，并选举出新的领导者后，整个系统还能稳定运行呢？欢迎在留言区分享你的看法，与我一同讨论。

线性一致性是什么意思

如何推导的？
我想说的是，这个算法有个非常致命的缺陷。如果将军数为 n、叛将数为 f，那么算法需要递归协商 f+1 轮，消息复杂度为 O(n ^ (f + 1))，消息数量指数级暴增。你可以想象一下，如果叛将数为 64，消息数已经远远超过 int64 所能表示的了，这是无法想象的，肯定不行啊。


兰伯特的 Multi-Paxos，虽然能保证达成共识后的值不再改变，但它不关心达成共识的值是什么，也无法保证各值（也就是操作）的顺序性。而这就是 Zookeeper 没有采用 Multi-Paxos 的原因，又是 ZAB 协议着力解决的

ZAB 协议的最核心设计目标（如何实现操作的顺序性）
Paxos 虽然能保证达成共识后的值不再改变，但它不关心达成共识的值是什么。”


Basic Paxos 算法，描述的是多节点之间如何就某个值（提案 Value）达成共识；
Multi-Paxos 思想，描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。

针对 Basic Paxos 的局限性 Multi-Paxos 又是如何改进的。

zookeeper因为只能leader写，因此处理写并发性能不高