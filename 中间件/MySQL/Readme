#### 一条SQL在Mysql中执行过程
> 客户端发送一条sql指令，先经过Server端的「接收器」接收，然后经过「解释器」进行解析，如果是一个查询SQL，则到「缓存」中查询是否命中，cache-miss时为了优化执行效率，会先经过「优化器」对SQL进行优化，然后将优化后的SQL交给「执行器」，最终执行SQL会调用存储引擎查找数据。  
> 连接器：作为服务端用来接收客户端发起的连接，包括鉴权、心跳检测。  
> 缓存器：Mysql中的缓存是以k-v形式存储的，key是查询语句，value就是查询结果；大多数情况下mysql的缓存都是弊大于利，因为对于频繁更新的表而言，每次数据变动都需要清除整个表的缓存记录，在8.0里已经彻底废弃了mysql缓存的功能。  
> 分析器：在执行SQL之前，mysql会对sql语句进行分析，首先要进行的是「词法分析」，将一条sql语句按照关键字，拆出select、列名、表名等信息；识别完成后进行「语法分析」，检查sql语句是否正确可执行。  
> 优化器：对SQL执行方案进行优化，例如选择索引的顺序，或者联合查询时决定连接表顺序，这些都是由优化器实现的。  
> 执行器：对SQL和当前登录用户鉴权校验；然后调用「存储引擎」进行逐行扫描（如果有索引则扫索引，如果没有索引扫原始数据行）

#### Chatper2
> 为了避免mysql服务器在写数据时频繁进行I/O操作，一般server端(仅限innoDB引擎)会先生成写入日志(redo log)，然后再异步根据日志将要插入的数据行找到合适的位置插入，并同时建立索引，这步就是WAL技术。
> 如果redo log写满时，mysql便会不得不进行刷盘，需要将redo log全部以数据形式写入。
> redo log和binlog区别
> 二阶段提交是如何保证redolog和binlog数据一致性的

#### Chatper3
> Mysql的4个隔离级别，一般线上用RR级别，为什么不用RC呢？如果用RC会带来什么问题？什么场景下可以用RC呢？
> 可重复读是如何实现的，MVCC实现原理；回滚日志什么时候删除？

#### Chapter4
> mysql为什么要用b+tree，而不用二叉树；b+tree是几叉树，根据什么算的？
> 索引维护：页分裂与页合并过程
> 哪些场景需要使用自增主键，哪些不需要？

#### Chatper5
> select * from T where k between 3 and 5，需要执行几次树的搜索操作，会扫描多少行？
> 索引下推执行过程

#### Chatper6
> 什么时候需要用数据库级别锁？例如全局锁、表级锁和行级锁
> 如何安全的给一个请求量大，但数据量小的表加字段？

#### Chatper7
> Mysql事务是如何用二段提交实现行锁功能。
> 由于mysql是按需加锁，所以如果一个事务中有多个修改操作，应该将最有可能并发锁的的操作往后放。以买电影票为例:1.扣减用户余额；2.电影院票数减1；此时「用户记录」并发度相对「电影院票数」并发度更低，因此最好将电影院票数操作滞后
> 数据库是如何出现死锁的？如何避免出现死锁
>> A：例如：
>> ① [T1] update xxx where id = 1;【T1对id=1记录持有锁】  
>> ② [T2] update xxx where id = 2;【T2对id=2记录持有锁】  
>> ③ [T1] update xxx where id = 2;【T1尝试对id=2记录持有锁，但需要等待T2释放】  
>> ④ [T2] update xxx where id = 1;【T2尝试对id=1记录持有锁，但需要等待T1释放】 
>> 死锁往往无法避免，只能通过一些参数配置来解决:
>> ① 配置timeout让其超时，弊端是超时时间并不好掌握  
>> ② 配置自动检测，发现死锁后回滚其中一个事务，让另一个得以执行，但弊端是由于每个执行事务的线程都要检查依赖线程，因此性能耗费巨大，带来系统负载过高。
>> ③ 从设计上解决：将热点数据拆分成多个热点数据，让多个子热点数据平均承担并发，减少死锁的概率。

#### Chapter8 * 
> begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。
> 在RR隔离级别下，事务在启动之初就会对整库拍下快照
> 整理如果多个事务开始，其内部MVCC和tx_rowid以及read_view的运行过程。 

#### Chapter9 *
> 唯一索引和普通索引查询过程、更新过程
> change buffer工作原理

#### 
> 执行一个SQL返回数据量特别多的时候，还需要通过断开连接来释放Server端内存吗
> 不同引擎的特点，以及使用场景

#### 其他
1.mysql innordb存储引擎的B+tree，默认每个索引页是16K，每个索引节点是数据类型长度+6字节下一层的指针引用，以索引类型bigint为例，bigint占用8字节+6字节引用=14字节，最终一页16上能存1000+个节点。
Q：像B+Tree这种多叉树怎么平衡调整？

2.mysql的主键为什么推荐要一定是自增整型？
A：相比字符串的UUID，整型的存储空间消耗更少，查找效率更高。
   第二点，mysql innordb采用聚簇索引存储数据，当一个数据页满了之后，此时如果要在本页插入一个数据，会导致数据页向下裂变，增加树的高度。
